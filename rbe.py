# -*- coding: utf-8 -*-
"""RBE_Scheme_over_integers_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CBj80cL3gpeEpngIbe-j1vGVesnH7u9U

# **Utils encryption functions**
"""

import random
from typing import List, Tuple

def is_prime(n: int) -> bool:
    """Check if n is prime using trial division."""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True


def prime_factors(n: int) -> set:
    """Returns the set of prime factors of n."""
    factors = set()
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.add(i)
    if n > 1:
        factors.add(n)
    return factors


def is_generator(g: int, p: int) -> bool:
    """
    Checks if g is a generator of the multiplicative group Z_p*.

    Args:
        g: Candidate generator
        p: Prime number (modulus of the group)

    Returns:
        True if g is a generator, False otherwise
    """
    if not is_prime(p):
        raise ValueError("p must be prime to check for generator.")

    # Group order is p - 1 for Z_p*
    group_order = p - 1

    # Factor the group order
    factors = prime_factors(group_order)

    # g is a generator if g^(group_order / q) mod p != 1 for all prime factors q
    for factor in factors:
        if pow(g, group_order // factor, p) == 1:
            return False

    return True


def select_random_generator(p: int) -> int:
    """
    Select a random generator of Z_p*.
    """
    if not is_prime(p):
        raise ValueError("p must be prime to select generator.")

    while True:
        g = random.randint(2, p - 2)
        if is_generator(g, p):
            return g


def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
    """Extended Euclidean algorithm."""
    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y


def modular_inverse(a: int, m: int) -> int:
    """Compute modular multiplicative inverse of a mod m."""
    gcd, x, _ = extended_gcd(a, m)
    if gcd != 1:
        raise Exception("Modular inverse does not exist")
    return x % m


def generate_modular_set(l: int, P: int, value: int) -> List[int]:
    """Generate random coefficients that sum to value mod P."""
    r = [random.randrange(0, P) for _ in range(l - 1)]
    last = (value - sum(r)) % P
    r.append(last)
    return r


def modular_multiply_sets(
    set1: List[int],
    set2: List[int],
    reg: int,
    p: int,
    r_inv_products: List[List[int]] = None
) -> List[int]:
    """
    Homomorphic multiplication for public key version.
    """
    l = len(set1)

    # Step 1: Compute all pairwise products (Cartesian product)
    cartesian_products = []
    powers = []
    r_indices = []

    for i in range(l):
        for j in range(l):
            product = (set1[i] * set2[j]) % p
            power = i + j + 2
            cartesian_products.append(product)
            powers.append(power)
            r_indices.append((i, j))

    # Step 2: Reduce powers and aggregate
    result = [0] * l

    for idx, (prod, power, (i, j)) in enumerate(zip(cartesian_products, powers, r_indices)):
        current_power = power
        current_prod = prod

        # Apply regulator to reduce power
        while current_power > l:
            current_prod = (current_prod * reg) % p
            current_power -= l

        # Map to result index
        result_idx = current_power - 1

        # Apply compensation for r coefficient mismatch
        if r_inv_products is not None:
            compensation = r_inv_products[i][j][result_idx]
            current_prod = (current_prod * compensation) % p

        result[result_idx] = (result[result_idx] + current_prod) % p

    return result

"""# **Interfaces of basic RBE**"""

class HomomorphicScheme:
    def keygen(self):
        raise NotImplementedError

    def encrypt(self, m: int):
        raise NotImplementedError

    def decrypt(self, c):
        raise NotImplementedError

    def add(self, c1, c2):
        return [(a + b) % self.P for a, b in zip(c1, c2)]

    def multiply(self, c1, c2):
        raise NotImplementedError

"""# **The encryption scheme**"""

class ToyFHEncryptor:

    def __init__(self, P: int, l: int):
        if not is_prime(P):
            raise ValueError("P must be prime")

        self.P = P
        self.l = l
        self.k = None  # Will be stored temporarily during key generation
        self.private_key = None  #  k_powers list
        self.public_key = None
        self.reg = None
        self.r = None  # Still needed for compensation table
        self.r_compensation_table = None

    def keygen(self):
        """
        Generate keys:
        1. Uses select_random_generator()
        2. Private key is now just k_powers list (not a dictionary)
        3. k is stored temporarily but not in final private key
        """
        # Select proper generator
        self.k = select_random_generator(self.P)

        # k powers: {k^1, ..., k^l}
        k_powers = [
            pow(self.k, i + 1, self.P) for i in range(self.l)
        ]

        # r_i coefficients such that sum r_i = 1
        self.r = generate_modular_set(self.l, self.P, 1)

        # Public key: S_e = {r_i * k^(i+1)}
        self.public_key = [
            (self.r[i] * k_powers[i]) % self.P
            for i in range(self.l)
        ]

        # private key:the k_powers list
        self.private_key = k_powers

        # Regulator
        k_l = pow(self.k, self.l, self.P)
        self.reg = modular_inverse(k_l, self.P)

        # Precompute compensation table
        self.r_compensation_table = []
        for i in range(self.l):
            row = []
            for j in range(self.l):
                col = []
                r_i_r_j = (self.r[i] * self.r[j]) % self.P
                r_i_r_j_inv = modular_inverse(r_i_r_j, self.P)
                for k in range(self.l):
                    compensation = (self.r[k] * r_i_r_j_inv) % self.P
                    col.append(compensation)
                row.append(col)
            self.r_compensation_table.append(row)

        # Clear k after key generation
        # We can still recover it as private_key[0] if needed
        # self.k = None

    def encrypt(self, m: int):
        """
        Encrypt using public key.
        """
        m_normalized = m % self.P
        m_set = generate_modular_set(self.l, self.P, m_normalized)

        # encryption with public key
        return [
            (m_set[i] * self.public_key[i]) % self.P
            for i in range(self.l)
        ]

    def decrypt(self, c):
        """
        Decrypt using private key.
        """
        m = 0
        for i in range(self.l):
            # Compute inverse of (r[i] * k^(i+1))

            inv_k = modular_inverse(self.private_key[i], self.P)
            inv_r = modular_inverse(self.r[i], self.P)
            inv_total = (inv_k * inv_r) % self.P

            m = (m + inv_total * c[i]) % self.P

        # Convert to signed representation
        if m > self.P // 2:
            m -= self.P

        return m

    def add(self, c1, c2):
        """ Homomorphic addition """
        return [(a + b) % self.P for a, b in zip(c1, c2)]

    def multiply(self, c1, c2):
        """
        Homomorphic multiplication with compensation
        """
        return modular_multiply_sets(c1, c2, self.reg, self.P, self.r_compensation_table)

"""# **Demo of HE**"""

if __name__ == "__main__":
    print("="*80)
    print("RBE SCHEME - Test Demo")
    print("="*80)

    P = 28871271685163
    l = 2

    rbe = ToyFHEncryptor(P, l)
    rbe.keygen()

    print("KEYS:")
    print(f"  Generator k: {rbe.k} (verified generator of Z_p*)")
    print(f"  Public key: {rbe.public_key}")
    print(f"  Private key (k_powers): {rbe.private_key}")
    print(f"  r coefficients: {rbe.r}")
    print(f"  Compensation table: {rbe.l}x{rbe.l}x{rbe.l} matrix")
    print()

    # Verify k is a generator
    print(f"  Verified: is_generator({rbe.k}, {rbe.P}) = {is_generator(rbe.k, rbe.P)}")
    print()

    # Basic test
    m1 = -110
    m2 = -3

    print("="*80)
    print("BASIC TEST")
    print("="*80)

    c1 = rbe.encrypt(m1)
    c2 = rbe.encrypt(m2)

    print(f"m1 = {m1}, decrypt(encrypt(m1)) = {rbe.decrypt(c1)}")
    print(f"m2 = {m2}, decrypt(encrypt(m2)) = {rbe.decrypt(c2)}")
    print()

    c_add = rbe.add(c1, c2)
    print(f"Addition:       {rbe.decrypt(c_add)} (expected: {m1 + m2})")

    c_mul = rbe.multiply(c1, c2)
    print(f"Multiplication: {rbe.decrypt(c_mul)} (expected: {m1 * m2})")
    print()

    # Extended tests
    print("="*80)
    print("EXTENDED TEST SUITE")
    print("="*80)
    print()

    test_cases = [
        (18, 3),
        (10, -4),
        (-7, -8),
        (0, 5),
        (15, 0),
        (1, 1),
        (-1, -1),
        (-9, 3),
    ]

    all_passed = True
    for m1, m2 in test_cases:
        c1 = rbe.encrypt(m1)
        c2 = rbe.encrypt(m2)

        c_add = rbe.add(c1, c2)
        c_mul = rbe.multiply(c1, c2)

        result_add = rbe.decrypt(c_add)
        result_mul = rbe.decrypt(c_mul)

        expected_add = m1 + m2
        expected_mul = m1 * m2

        add_ok = result_add == expected_add
        mul_ok = result_mul == expected_mul

        status = '✓' if (add_ok and mul_ok) else '✗'
        print(f"{status} m1={m1:4}, m2={m2:4} -> Add: {result_add:5} ({expected_add:5}) | Mul: {result_mul:5} ({expected_mul:5})")

        if not (add_ok and mul_ok):
            all_passed = False

    print()
    print(f"All tests passed: {all_passed} {'✓✓✓' if all_passed else '✗✗✗'}")
    print()

# Commented out IPython magic to ensure Python compatibility.
# # Save RBE as a python module
# %%writefile rbe.py
# # paste ONLY the final working RBE class and utils here
#